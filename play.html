<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Playground</title>
  </head>
  <body>
    <div id="root"></div>
    <!-- Глобальные React и ReactDOM для JSX без импортов -->
    <script type="module">
      import * as ReactModule from 'react';
      import * as ReactDOMClientModule from 'react-dom/client';
      window.React = ReactModule;
      window.ReactDOM = ReactDOMClientModule;
    </script>
    <script type="module">
      // Принудительный full reload при любых HMR-событиях (устойчиво в StackBlitz)
      if (import.meta && import.meta.hot) {
        import.meta.hot.on('vite:beforeUpdate', () => location.reload());
        import.meta.hot.on('vite:invalidate', () => location.reload());
        import.meta.hot.on('vite:error', () => location.reload());
      }
      const params = new URLSearchParams(window.location.search);
      const file = params.get('file');

      if (!file) {
        document.getElementById('root').innerHTML = '<p>Добавьте параметр ?file=путь/к/файлу</p>';
      } else {
        // Декодируем кириллические символы в пути файла
        const safeDecode = (s) => { try { return decodeURIComponent(s); } catch { return s; } };
        const decodedFile = safeDecode(file);
        const toVariants = (p) => {
          const noHash = p.split('#')[0];
          const noQuery = noHash.split('?')[0];
          const norm = noQuery.replace(/\\/g, '/');
          const withSrc = norm.replace(/^\/@src\//, '/src/');
          const ensureAbs = withSrc.startsWith('/') ? withSrc : '/' + withSrc.replace(/^\/+/, '');
          const relDot = '.' + ensureAbs;
          const rel = ensureAbs.replace(/^\//, '');
          const relDot2 = './' + rel;
          return [ensureAbs, relDot, rel, relDot2];
        };
        
        if (decodedFile.endsWith('.html')) {
          // Загружаем HTML как текст и встраиваем через Blob, чтобы избежать
          // проблем с доменом/кодировкой и лишних 404 в embed
          const fetchVariants = (p) => {
            const vs = toVariants(p);
            // Пытаемся сначала абсолютом, затем относительными
            return vs;
          };
          (async () => {
            const variants = fetchVariants(decodedFile);
            let html = '';
            let ok = false;
            for (const v of variants) {
              try {
                const r = await fetch(v);
                if (r.ok) {
                  html = await r.text();
                  ok = true;
                  break;
                }
              } catch {}
            }
            if (!ok) {
              document.getElementById('root').innerHTML = '<p>Не удалось загрузить HTML: '+decodedFile+'</p>';
              return;
            }
            const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
            const blobUrl = URL.createObjectURL(blob);
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100vh';
            iframe.style.border = '0';
            iframe.src = blobUrl;
            document.body.appendChild(iframe);
          })();
        } else if (decodedFile.endsWith('.jsx') || decodedFile.endsWith('.tsx') || decodedFile.endsWith('.js') || decodedFile.endsWith('.ts')) {
          // Собираем карту модулей заранее, чтобы Vite знал об импортах
          const modules = {
            ...import.meta.glob('./src/**/*.{jsx,tsx,js,ts}'),
            ...import.meta.glob('/src/**/*.{jsx,tsx,js,ts}'),
            ...import.meta.glob('./@src/**/*.{jsx,tsx,js,ts}'),
            ...import.meta.glob('/@src/**/*.{jsx,tsx,js,ts}')
          };

          const candidates = toVariants(decodedFile);
          const loader = candidates.map((k) => modules[k]).find(Boolean);

          const load = loader
            ? loader()
            : import(/* @vite-ignore */ decodedFile);

          load.then((mod) => {
            const container = document.getElementById('root');
            const mount = mod.default || mod.App || mod.Component;

            const renderWithReact = (nodeOrComponent) => {
              import('react-dom/client').then(({ createRoot }) => {
                const root = createRoot(container);
                root.render(nodeOrComponent);
              });
            };

            if (typeof mount === 'function') {
              import('react').then(({ createElement }) => renderWithReact(createElement(mount)));
              return;
            }
            if (mod.default && window.React && window.React.isValidElement?.(mod.default)) {
              renderWithReact(mod.default);
              return;
            }
            if (typeof mod.render === 'function') {
              mod.render(container);
              return;
            }
            if (typeof mod.run === 'function') {
              mod.run(container);
              return;
            }

            // Фоллбек: модуль мог сам смонтироваться побочным эффектом
            queueMicrotask(() => {
              if (container && container.childNodes && container.childNodes.length > 0) return;
              container.innerHTML = '<p>Модуль не экспортирует React-компонент, элемент или функцию run/render</p>';
            });
          }).catch((e) => {
            console.error(e);
            document.getElementById('root').innerHTML = '<pre style="white-space: pre-wrap;">'+String(e)+'</pre>';
          });
        } else {
          document.getElementById('root').innerHTML = '<p>Неподдерживаемый тип файла: '+decodedFile+'</p>';
        }
      }
    </script>
  </body>
  </html>


